bus/
├── bus_transaction.sv      // Transaction class
├── bus_sequence.sv         // Sequence class
├── bus_sequence_prio.sv    // Additional Sequence class
├── bus_sequencer.sv        // Sequencer class
├── bus_driver.sv           // Driver class
├── bus_monitor.sv          // Monitor class
├── bus_consumer.sv         // Consumer class
├── bus_env.sv              // Env class
├── bus_test.sv             // Test class
└── bus_tb.sv               // Testbench top

Data Flow
─────────
1. bus_tb - Simulation begins and runs bus_test class
2. bus_test::build_phase() - The test creates only the environment. All components (drv, mon, sqr) are now built inside the bus_env.
3. bus_test::run_phase() - Three sequence objects are created: bus_sequence, high_prio_seq and low_prio_seq. Uses fork...join to run all 3 sequences in parallel. The test's objection is raised
4. bus_env - It instantiates bus_driver, bus_monitor, bus_sequencer and bus_consumer
5. bus_env::build_phase() - Instantiate drv, mon, sqr, consumer. Use UVM factory to create these components
6. bus_env::connect_phase() - Driver’s seq_item_port connects to sequencer’s seq_item_export. Driver's analysis port connected to monitor's analysis implementation. Monitor's put port connected to consumer's put implementation. The bus_env allows full decoupling i.e. bus_test connects only to bus_env; bus_env handles internal connections
7. bus_sequence::body() - Transactions are created. Each transaction is randomized. There are three sequences: bus_sequence creates 7 transactions, high_prio_seq creates 3 transactions and prevents others from accessing sequencer while locked, low_prio_seq creates 3 transactions. All sequences are done using start_item() and finish_item()
8. Sequencer Arbitration - Sequencer env.sqr receives requests from all 3 sequences. Since high_prio_seq locks the sequencer, it gets exclusive access while locked. Normal and low priority sequences compete for access after lock is released
9. bus_driver::run_phase() - The driver dequeues transactions. Prints the transaction data. Waits for 10 time units (simulating DUT interaction). Acknowledges transaction completion (item_done()). It also writes each received transaction to the analysis port: ap.write(tr). Now transactions are sent to both the DUT simulation (not implemented) and also broadcast via analysis port
10. bus_monitor - It is connected to environment's ap_export via its own ap_implementation. When driver sends a transaction on analysis port, monitor's write() method receives it and prints the observed transaction. It simply observes and prints all transactions that the driver has handled
11. bus_consumer - Consumer is connected to monitor’s put port. The consumer receives transactions via its put() function. The consumer checks and counts error

% cp ../../lab9/design/* ../design
% vim ../design/bus_consumer.sv
Please copy the Content1 into it, see below

Content1
────────
class bus_consumer extends uvm_component;
   `uvm_component_utils(bus_consumer)

   uvm_put_imp #(bus_transaction, bus_consumer) put_imp;

   // Counter and error flag
   int num_received;
   int num_errors;

   function new(string name, uvm_component parent);
      super.new(name, parent);
      put_imp = new("put_imp", this);
      num_received = 0;
      num_errors = 0;
   endfunction

   // Required by uvm_put_imp to have put(), can_put() and try_out()
   function bit can_put();
      return 1; // Always ready to receive
   endfunction

   function bit try_put(bus_transaction tr);
      put(tr);
      return 1;
   endfunction

   // Receive transactions here
   virtual function void put(bus_transaction tr);
      num_received++;

      `uvm_info("CONSUMER",
                $sformatf("Received transaction: addr=0x%2h, data=0x%8h, write=%0b",
                          tr.addr, tr.data, tr.write),
                UVM_LOW)

      // Example check: write should be 1
      if (tr.write == 0) begin
         num_errors++;
         `uvm_error("CONSUMER_CHECK",
                    $sformatf("Invalid transaction! addr=0x%2h, data=0x%8h, write=%0b <<<<<<<<<<<<<<<<",
                              tr.addr, tr.data, tr.write))
      end
   endfunction

   // Print summary at end of simulation
   function void report_phase(uvm_phase phase);
      `uvm_info("CONSUMER_REPORT",
                $sformatf("Total received transactions: %0d", num_received),
                UVM_NONE)
      `uvm_info("CONSUMER_REPORT",
                $sformatf("Total errors detected: %0d", num_errors),
                UVM_NONE)
   endfunction
endclass

% vim ../design/bus_tb.sv
Include the new bus_consumer.sv right after bus_monitor.sv, see below
   `include "bus_consumer.sv"  // Lab 10

% vim ../design/bus_env.sv
Remember to setup the consumer, add each of the following to the right line, see below
   bus_consumer consumer;  // Lab 10
      consumer = bus_consumer::type_id::create("consumer", this);  // Lab 10
Add these after the line 'qr.seq_item_export', see below
      // Connect monitor's put port to consumer's implementation
      mon.put_port.connect(consumer.put_imp);  // Lab 10

      // Connect driver analysis port to monitor's implementation
      drv.ap.connect(mon.ap_implementation);  // Lab 10
Comment these out, see below
   //uvm_analysis_export #(bus_transaction) ap_export;
      //ap_export = new("ap_export", this);
      //drv.ap.connect(ap_export);
      //ap_export.connect(mon.imp);

% vim ../design/bus_monitor.sv
Remember to setup the consumer, add each of the following to the right line, see below
   uvm_put_port #(bus_transaction) put_port;  // Lab 10
      put_port = new("put_port", this);  // Lab 10
Add these right after the `uvm_info line, see below
      fork  // Lab 10
         do_put(tr);
      join_none
Add these right before the endclass line, see below
   task do_put(bus_transaction tr);  // Lab 10
      put_port.put(tr);
   endtask

% make dv
Observe STDOUT
Observe the UVM messages

% vim bus_sim.log
Note that there are 7 (bus_sequence), 3 (high_prio_seq), 2 (low_prio_seq) transactions
NOte that there are similar transactions printed by [MONITOR]
NOte that there are similar transactions printed by [CONSUMER]
Pay attention to the transactions printed by [CONSUMER_CHECK]

% grep UVM_ bus_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab10/lab10/' > diff1
% diff diff1 diff1.orig
There should be no discrepency

Data Flow Diagram
─────────────────
+------------------------------------------------------+
|                  bus_tb (Top Module)                 |
|  - run_test("bus_test")                              |
+------------------------------------------------------+
                           |
                           v
+------------------------------------------------------+
|                  bus_test (UVM Test)                 |
|  - build_phase: creates env                          |
|  - run_phase: raises objection                       |
|  - run_phase: launches sequences in parallel:        |
|      * bus_sequence (7 transactions)                 |
|      * high_prio_seq (3 transactions, locked)        |
|      * low_prio_seq (2 transactions)                 |
+------------------------------------------------------+
                           |
                           v
+------------------------------------------------------+
|                   bus_env (Environment)              |
|  - build_phase: creates drv, mon, sqr, consumer      |
|  - connect_phase:                                    |
|      * drv.seq_item_port <-> sqr.seq_item_export     |
|      * drv.ap <-> ap_export <-> mon.ap_implementation|
|      * mon.put_port <-> consumer.put_imp             |
+------------------------------------------------------+
                           |   |   |
                           |   |   |
                           |   |   +-----------------------------+
                           |   |                                 |
                           |   +-----------------------------+   |
                           |                                 |   |
                           +-----------------------------+   |   |
                                                         |   |   |
                                                         |   |   |
+----------------------------------------------------+   |   |   |
|                bus_sequence (Sequence)             |   |   |   |
|  - Creates the three sequences                     |   |   |   |
|  - Randomizes: addr[7:4]=A, write=1 bus_sequence   |   |   |   |
|  - Randomizes: addr[7:4]=F, write=0 high_prio_seq  |   |   |   |
|  - Randomizes: addr[7:4]=E, write=0 low_prio_seq   |   |   |   |
|  - start_item() / finish_item() for each sequence  |   |   |   |
+----------------------------------------------------+   |   |   |
                           |                             |   |   |
                           v                             |   |   |
+----------------------------------------------------+   |   |   |
|                bus_sequencer (Sequencer)           |   |   |   |
|  - Handles sequence priority:                      |   |   |   |
|      * Processes high_prio_seq first (due to lock) |<--+   |   |
|      * Then processes bus_sequence and low_prio_seq|       |   |
|  - Forwards transactions to driver via TLM port    |       |   |
+----------------------------------------------------+       |   |
                           |                                 |   |
                           v                                 |   |
+----------------------------------------------------+       |   |
|                 bus_driver (Driver)                |       |   |
|  - get_next_item(tr)                               |       |   |
|  - Prints transaction info:                        |       |   |
|     * High priority: addr[7:4]=F, write=0          |       |   |
|     * Normal: addr[7:4]=A, write=1                 |<------+   |
|     * Low priority: addr[7:4]=E, write=0           |           |
|  - Sends transaction to monitor via ap.write(tr)   |           |
|  - Simulates DUT interaction (delay)               |           |
|  - item_done()                                     |           |
+----------------------------------------------------+           |
                           |       | (via analysis port)         |
                           |       v                             v
                           |   +----------------------------------------------------+
                           |   |                 bus_monitor (Monitor)              |
                           |   |  - Receives transactions via write() method        |
                           |   |  - Prints observed transaction info                |     
                           |   |  - Calls do_put() i.e. put_port.put(tr)            |
                           |   +----------------------------------------------------+
                           |       ^                                              |
                           v       |                                              v
+----------------------------------------------------+   +----------------------------------------------------+
|      (DUT - Not present)                           |   |                bus_consumer (Consumer)             |
+----------------------------------------------------+   |  - Receives transactions via put() method          |
                           |                             |  - Checks transactions (write must be 1)           |
                           |                             |  - Counts received transactions and errors         |
                           |             +---------------|  - Reports summary at end of simulation            |
                           |             |               +----------------------------------------------------+
                           v             v
+----------------------------------------------------+
|                  bus_test (UVM Test)               |
|  - run_phase: drops objection                      |
+----------------------------------------------------+
