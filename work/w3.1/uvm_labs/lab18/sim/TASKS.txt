bus/
├── bus_ctrl.sv      // Bus Controller Module
├── bus_ctrl_if.sv   // Bus Controller Interface
├── bus_tran.sv      // Transaction class
├── bus_seq.sv       // Sequence class
├── bus_seq_prio.sv  // Additional Sequence class (will not be used)
├── bus_sqr.sv       // Sequencer class
├── bus_drv.sv       // Driver class
├── bus_mon.sv       // Monitor class
├── bus_agt.sv       // Agent class
├── bus_wrt.sv       // User defined class
├── bus_con.sv       // Consumer class (will not be used)
├── bus_scb.sv       // Scoreboard class
├── bus_cov.sv       // Coverage class
├── bus_env.sv       // Env class
├── bus_test.sv      // Test class
└── bus_tb.sv        // Testbench top

Bus Controller
──────────────
Memory and Register Storage
  256-entry memory array (32-bit words)
  Reserved space at addresses 0xF0-0xFF
  Two Registers:
    control_reg (32-bit) at addresses 0xA0-0xAF, write/read
    status_reg (32-bit) at addresses 0xB0-0xBF, read
  Interface Signals
    Clock (clk) and active-low reset (reset_n)
    8-bit address bus (addr)
    32-bit write data (wdata) and read data (rdata)
    Control signals:
      write: distinguishes between read/write operations
      valid: indicates valid bus transaction
      ready: handshake signal for transaction completion
Functional Description
  Address Decoding
    Uses combinatorial logic to check for reserved addresses (0xF0-0xFF)
    Sets addr_valid flag to 0 for reserved addresses
  Main Operation Handling
    Synchronous to clock edge with asynchronous reset
    On reset:
      Clears all registers and memory
      Initializes outputs to zero
    During normal operation:
      Processes valid transactions when valid is high and address is valid
      Handles both write and read operations:
        Write operations:
          Writes to control_reg for addresses 0xA0-0xAF
          Writes to memory for all other valid addresses
        Read operations:
          Reads from control_reg for addresses 0xA0-0xAF
          Reads from status_reg for addresses 0xB0-0xBF
          Reads from memory for all other valid addresses
      Updates status register after each operation:
        Bit 31: operation complete flag
        Bits 7-0: last accessed address
        Bit 30: error flag (set for invalid address access)
  Handshake Protocol
    Asserts ready signal when:
      A valid operation completes
      An invalid address is accessed (with error flag set)
  Reserved Address Space
    Addresses 0xF0-0xFF are reserved and will trigger:
      addr_valid = 0
      Error flag in status register
      Immediate ready assertion
  Initialization
    On reset, all memory locations and registers are initialized to 0

% cp ../../lab17/design/bus*.sv ../design
% cp ../../lab17/design/bus.f ../design

% vim ../design/bus_env.sv
Comment out the connection to bus_con, see below
    //agt.agt_ap.connect(con.con_imp);
Leave the FIFO out

% vim ../design/bus_drv.sv
Move this '@(vif.drv_cb);' line to right above '`uvm_info'

% vim ../design/bus_ctrl_if.sv
Comment out the whole 'task automatic' block

% vim ../design/bus_mon.sv
Add in this before the 'tr_dut.tran_ready' line, see below
      tr_dut.tran_time = $time;

% vim ../design/bus_tb.sv
Include the new bus_wrt.sv right after bus_agt.sv
Add in these after the clock initial block, see below
  initial begin
    bus_if.reset_n_tb = 0;
    bus_if.valid_tb = 0;
    bus_if.write_tb = 0;
    bus_if.addr_tb = 0;
    bus_if.wdata_tb = 0;
    #20 bus_if.reset_n_tb = 1;
  end

% mv ../design/bus_seq.sv ../design/bus_seq.sv.old
% vim ../design/bus_seq.sv
Please copy the Content1 into it, see below

Content1
────────
class bus_seq extends uvm_sequence #(bus_tran);
  `uvm_object_utils(bus_seq)

  int min_delay;
  int max_delay;
  int delay;
  int seq_count;
  int seq_index;
  int is_read;
  string seq_type;
  string seq_dir;

  bit [7:0] wr_addr_pool[$];  // Store addresses previously written

  function new(string name = "bus_seq");
    super.new(name);
    seq_index = 0;
    seq_type = "normal";
  endfunction

  function int get_random_delay();
    return $urandom_range(min_delay, max_delay);
  endfunction

  task body();
    bus_tran tr;
    `uvm_info(get_type_name(), "Normal Priority Sequence", UVM_MEDIUM)
    repeat (seq_count) begin
      seq_index++;

      is_read = $urandom_range(0, 1);  // Decide randomly: 0 = WR, 1 = RD

      tr = bus_tran::type_id::create("tr");
      start_item(tr);

      if (!is_read) begin
        // Write data to a random address
        //assert(tr.randomize() with { write == 1; });
        assert(tr.randomize() with { addr[7:4] == 4'hA; write == 1; });
        //assert(tr.randomize() with { addr[7:4] == 4'hB; write == 1; });
        //assert(tr.randomize() with { (addr[7:4] != 4'hA && addr[7:4] != 4'hB && addr[7:4] != 4'hF); write == 1; });
        wr_addr_pool.push_back(tr.addr);
        seq_dir = "WR";
        `uvm_info(get_type_name(), $sformatf("Sent %s %0d/%0d %s seq: addr=0x%2h, data=0x%8h, write=%0b",
                                             seq_dir, seq_index, seq_count, seq_type, tr.addr, tr.data, tr.write),
                                             UVM_MEDIUM)
      end else begin
        // Read the data back from the write adddress
        if (wr_addr_pool.size() > 0) begin
            int rand_idx = $urandom_range(0, wr_addr_pool.size()-1);
            tr.addr = wr_addr_pool[rand_idx];
          end
          else begin
            tr.addr = 8'hB0;
          end
        tr.write = 0;
        delay = get_random_delay();
        seq_dir = "RD";
        `uvm_info(get_type_name(), $sformatf("Sent %s %0d/%0d %s seq: addr=0x%2h, data=0x%8h, write=%0b Next seq after %0d",
                                             seq_dir, seq_index, seq_count, seq_type, tr.addr, tr.data, tr.write, delay),
                                             UVM_MEDIUM)
        #delay;
      end

      tr.seq_count = this.seq_count;
      tr.seq_index = this.seq_index;
      tr.seq_type = this.seq_type;
      tr.seq_dir = this.seq_dir;

      finish_item(tr);
    end
  endtask
endclass

% mv ../design/bus_scb.sv ../design/bus_scb.sv.old
% vim ../design/bus_scb.sv
Instead of using FIFO of bus_con a memory is created to store all the WR
Please copy the Content2 into it, see below

Content2
────────
class bus_scb extends uvm_scoreboard;
  `uvm_component_utils(bus_scb)

  // Use implementation port to receive transactions
  uvm_analysis_imp #(bus_tran, bus_scb) mon_imp;

  int passed_count = 0;
  int failed_count = 0;
  int passed_wr_count = 0;
  int passed_rd_count = 0;
  int failed_wr_res_count = 0;
  int failed_rd_res_count = 0;
  int tran_count;
  int tran_index;
  string tran_type;
  string tran_dir;

  int prio_wr;
  bit [31:0] prio_wr_data;
  int data_eq;
  // Memory mirrors
  bit [31:0] mem_mirror[256];  // unpacked array of 256 elements, each element is a packed 32-bit vector
  bit [31:0] ctrl_reg_mirror;
  bit [31:0] stat_reg_mirror;
  bit [31:0] resv_reg_mirror;
  bit [7:0]  real_addr;

  wrt addr_history[bit[7:0]][$];

  function new(string name, uvm_component parent);
    super.new(name, parent);
    mon_imp = new("mon_imp", this);
    foreach (mem_mirror[i]) mem_mirror[i] = 0;
    prio_wr_data = 0;
    ctrl_reg_mirror = 0;
    stat_reg_mirror = 0;
    resv_reg_mirror = 0;
    real_addr = 0;
  endfunction

  function void write(bus_tran tr_dut);
    `uvm_info("SCOREBOARD", $sformatf("%s %0d/%0d %s tran: addr=0x%2h, data=0x%8h, write=%0b",
                                      tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                      tr_dut.tran_type, tr_dut.addr, tr_dut.data, tr_dut.write),
                                      UVM_MEDIUM)
    // Handle transaction
    if (tr_dut.write == 1) begin

      if (tr_dut.addr inside {[8'hA0:8'hAF]}) begin
        ctrl_reg_mirror = tr_dut.data;
	real_addr = 8'hA0;
      end else if (tr_dut.addr inside {[8'hB0:8'hBF]}) begin
        stat_reg_mirror = tr_dut.data;
        real_addr = 8'hB0;
      end else if (tr_dut.addr inside {[8'hF0:8'hFF]}) begin
        resv_reg_mirror = tr_dut.data;
        real_addr = 8'hF0;
      end else begin
        real_addr = tr_dut.addr;
        mem_mirror[tr_dut.addr] = tr_dut.data;
      end

      // Store all write history
      addr_history[real_addr].push_back(wrt::type_id::create("wrt"));
      addr_history[real_addr][$].w_count = tr_dut.tran_count;
      addr_history[real_addr][$].w_index = tr_dut.tran_index;
      addr_history[real_addr][$].w_type = tr_dut.tran_type;
      addr_history[real_addr][$].w_dir = tr_dut.tran_dir;
      addr_history[real_addr][$].w_time = tr_dut.tran_time;
      addr_history[real_addr][$].w_addr = tr_dut.addr;
      addr_history[real_addr][$].w_data = tr_dut.data;

      //stat_reg_mirror[7:0] = tr_dut.addr;
      //stat_reg_mirror[31] = 1'b1; // Op complete
      //stat_reg_mirror[30] = 1'b0; // Clear error

      `uvm_info("SCOREBOARD_WR", $sformatf("%s %0d/%0d %s tran: addr=0x%2h, data=0x%8h, ctrl=0x%8h, stat=0%8h, resv=0%8h, time=%0t",
                                           tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                           tr_dut.tran_type, tr_dut.addr, tr_dut.data, ctrl_reg_mirror,
                                           stat_reg_mirror, resv_reg_mirror, tr_dut.tran_time), UVM_MEDIUM)

    end else begin

      bit [31:0] exp_data = get_expected_data(tr_dut.addr);
      string info_msg;

      if (tr_dut.addr inside {[8'hA0:8'hAF]}) begin
        real_addr = 8'hA0;
      end else if (tr_dut.addr inside {[8'hB0:8'hBF]}) begin
        real_addr = 8'hB0;
      end else if (tr_dut.addr inside {[8'hF0:8'hFF]}) begin
        real_addr = 8'hF0;
      end else begin
        real_addr = tr_dut.addr;
      end

      //stat_reg_mirror[31] = 1'b1; // Op complete

      `uvm_info("SCOREBOARD_RD", $sformatf("%s %0d/%0d %s tran: addr=0x%2h, data=0x%8h, ctrl=0x%8h, stat=0%8h, resv=0%8h, time=%0t",
                                           tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                           tr_dut.tran_type, tr_dut.addr, tr_dut.data, ctrl_reg_mirror,
                                           stat_reg_mirror, resv_reg_mirror, tr_dut.tran_time), UVM_MEDIUM)

      // Checking
      prio_wr = 0;
      prio_wr_data = 0;
      data_eq = 0;
      if (addr_history.exists(real_addr)) begin
        info_msg = $sformatf("\naddr=0x%2h Write history:", real_addr);
        foreach (addr_history[real_addr][i]) begin
          info_msg = {info_msg, $sformatf(
                      "\n  [%0d] \@%0t %s %0d/%0d %s tran: addr=0x%2h, data=0x%8h",
                      i,
                      addr_history[real_addr][i].w_time,
                      addr_history[real_addr][i].w_dir,
                      addr_history[real_addr][i].w_index,
                      addr_history[real_addr][i].w_count,
                      addr_history[real_addr][i].w_type,
                      addr_history[real_addr][i].w_addr,
                      addr_history[real_addr][i].w_data
                    )};
          if (tr_dut.addr == addr_history[real_addr][i].w_addr) begin
            prio_wr = 1;
	    prio_wr_data = addr_history[real_addr][i].w_data;
	    if (tr_dut.data == addr_history[real_addr][i].w_data) begin
              data_eq = 1;
            end
         end
        end
        `uvm_info("SCOREBOARD", info_msg, UVM_MEDIUM)
	if (prio_wr && data_eq) begin
          `uvm_info("SCOREBOARD_CHK", $sformatf("%s %0d/%0d %s tran: addr=0x%2h, data=0x%8h prio_wr_data=x%8h",
                                                tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                                tr_dut.tran_type, tr_dut.addr, tr_dut.data, prio_wr_data), UVM_MEDIUM)
        end else begin
          `uvm_error("SCOREBOARD_CHK", $sformatf("%s %0d/%0d %s tran: addr=0x%2h, data=0x%8h prio_wr_data=x%8h (WR data != RD data)",
                                                 tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                                 tr_dut.tran_type, tr_dut.addr, tr_dut.data, prio_wr_data))
        end
      end else begin
        `uvm_warning("SCOREBOARD_CHK", $sformatf("%s %0d/%0d %s tran: addr=0x%2h (No WR prior to RD)",
                                                 tr_dut.tran_dir, tr_dut.tran_index, tr_dut.tran_count,
                                                 tr_dut.tran_type, tr_dut.addr))
      end
    end
  endfunction

  real pass_rate;
  real fail_rate;
  bit test_passed;
  string test_summary;

  function void extract_phase(uvm_phase phase);
    // Calculate derived metrics
    int total_transactions = passed_count + failed_count;

    if (total_transactions > 0) begin
      // real' is a casting syntax, creates a temporary real (floating-point) version of the value
      // ' is called the cast operator
      pass_rate = (real'(passed_count) / real'(total_transactions)) * 100;
      fail_rate = (real'(failed_count) / real'(total_transactions)) * 100;
    end else begin
      pass_rate = 0;
      fail_rate = 0;
    end

    // Determine overall test status
    test_passed = (failed_count == 0);  // If failed_count is 0, return true or 1, meaning test_passed is true or 1
    test_summary = test_passed ? "TEST PASSED" : "TEST FAILED";
  endfunction

  function void check_phase(uvm_phase phase);
    // Final verification of test results
    if (failed_count > 0) begin
        `uvm_error("CHECK", $sformatf("Scoreboard detected %0d failures", failed_count))
    end

    // Additional checks could be added here, for example:
    // - Minimum transaction count requirements
    // - Specific pattern requirements
    // - Protocol violation checks
  endfunction

  function void report_phase(uvm_phase phase);
    `uvm_info("SCOREBOARD", test_summary, UVM_NONE)
    `uvm_info("SCOREBOARD", $sformatf("Pass Rate: %.2f%%", pass_rate), UVM_NONE)
    `uvm_info("SCOREBOARD", $sformatf("Passed Tran: Passed=%0d Passed(WR)=%0d Passed(RD)=%0d",
                                      passed_count, passed_wr_count, passed_rd_count), UVM_NONE)
    `uvm_info("SCOREBOARD", $sformatf("Failed Tran: Failed=%0d Failed(WR_RES)=%0d Failed(RD_RES)=%0d",
                                      failed_count, failed_wr_res_count, failed_rd_res_count), UVM_NONE)
  endfunction

  function bit [31:0] get_expected_data(bit [7:0] addr);
    case (addr[7:4])
      4'hA: return ctrl_reg_mirror;
      4'hB: return stat_reg_mirror;
      4'hF: return resv_reg_mirror;
      default: return mem_mirror[addr];
    endcase
  endfunction
endclass

% vim ../design/bus_test.sv
Comment out these, see below
      //hseq.start(env.agt.sqr);
      //lseq.start(env.agt.sqr);
    //wait(env.scb.tran_index == seq.seq_count);
Increase seq_count = 80

% vim ../design/bus_tran.sv
Add in this, see below
  int tran_time;

Please note that the scoreboard bus_scb.sv has not implemented all the checks
You need to explore the way to implement the checkers and create a pass/fail summary

% make dv
Observe STDOUT
Observe the UVM messages

% qgrep
See all the transactions

% urg -full64 -dir bus_simv.vdb -report bus_cov
% \ls -l `echo $ROOT/sim/bus_cov/dashboard.html`
Copy and paste the full path of dashboard.html to the web browser
